#!/usr/bin/env bash

#------------------------------------------------------------------------------
# File: eos-extstorage-test
# Author: Mihai Patrascoiu - CERN
#------------------------------------------------------------------------------

# *****************************************************************************
# EOS - the CERN Disk Storage System
# Copyright (C) 2018 CERN/Switzerland
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# *****************************************************************************

#------------------------------------------------------------------------------
# Description: Script testing EOS filesystems operating with external storage.
#              This script is intended to be used in the eos-docker setup,
#              where all the outside preparation has been done beforehand,
#              otherwise, the file paths will not work properly.
#
#              An --ssh flag is provided which allows the script to do the
#              needed preparation by itself. However, ssh access to the
#              FST instances is needed. This option is useful when testing
#              on an already existing EOS cluster.
#
#              It assumes at least 2 FSTs are available in the instance.
#
# Usage:
# eos-extstorage-test <eos_mgm_hostname> [--ssh] [--verbose]
#    <eos_mgm_hostname> - the name of the MGM host
#    --ssh              - attempt preparation set-up using ssh
#    --verbose          - trigger verbose output
#
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Input parsing
#------------------------------------------------------------------------------

if [[ $# -eq 0 || $# -gt 3 ]]; then
    echo "Usage: $0 <eos_mgm_hostname> [--ssh] [--verbose]"
    echo "          <eos_mgm_hostname> - the name of the MGM host"
    echo "          --ssh              - attempt preparation set-up using ssh"
    echo "          --verbose          - trigger verbose output"
    exit 1
fi

echo $1 | grep ":" &> /dev/null
[[ $? -ne 0 ]] && echo "Hostname must be of format: <host>:<port>" && exit 1
EOS_MGM_URL=$1

CONN_CLIENT=false
if [[ $2 == "--ssh" ]]; then
    CONN_CLIENT=true
    shift
fi

VERBOSE=false
if [[ $2 == "--verbose" ]]; then
    VERBOSE=true
fi

#------------------------------------------------------------------------------
# Utility functions
#------------------------------------------------------------------------------

print_test () {
    echo ""
    echo "-------------------------------------------------------------------------------"
    echo "TEST #${1}: ${2}"
    echo "      -- ${3}"
    echo "-------------------------------------------------------------------------------"
}

wait_result () {
    [[ ${VERBOSE} != false ]] && echo "Waiting ${3} seconds for ${4}"
    sleep 2
    COUNT=0

    while [[ $(eval $1) -ne ${2} ]]; do
        sleep 1
        COUNT=$((COUNT + 1))
        [[ ${VERBOSE} != false ]] && [[ ${VERBOSE} != "nocount" ]] && echo ${COUNT}
        [[ ${COUNT} -eq ${3} ]] && echo "error: timeout during ${4}" && return 1
    done

    return 0
}

#------------------------------------------------------------------------------
# Configuration
#------------------------------------------------------------------------------

# These variables are injected via Gitlab CI secrets
#EOS_FST_S3_ACCESS_KEY
#EOS_FST_S3_SECRET_KEY

# The mount points for the file systems
PATHS=( "/home/data/eos_lpath"
        "s3://s3.cern.ch/eostest/" )

# Assign spaces to the different mount points
SPACE=( "lpath_test" "s3_test" )

#------------------------------------------------------------------------------
# Preparation
#------------------------------------------------------------------------------

# Check preconditions
NUMFSTS=$((`eos node ls | grep "online" | wc -l`))

if [[ NUMFSTS -lt ${#PATHS[@]} ]]; then
    echo "error: minimum ${#PATHS[@]} FSTs should be configured"
    exit 1
fi

# Extract names of FST nodes
FSTS=($(eos -b node ls -m | grep hostport | cut -d\  -f 2 | cut -d= -f 2))
IDS=()

# Register file systems
${VERBOSE} && echo "Registering EOS file systems"

for (( i=0; i < ${#PATHS[@]}; i++ )); do
    HOST=${FSTS[$i]%%:*}
    eos fs ls -m | grep ${HOST} | grep ${PATHS[$i]} &> /dev/null

    # Add file system if not mounted already
    if [[ $? -ne 0 ]]; then
        [[ ${PATHS[$i]} == /* ]] && LOCAL_DRIVE=true || LOCAL_DRIVE=false
        UUID=`uuidgen`

        if ${LOCAL_DRIVE} && ${CONN_CLIENT}; then
            ssh ${HOST} mkdir -p ${PATHS[$i]} &> /dev/null
            ssh ${HOST} chown daemon:daemon -R ${PATHS[$i]}
            ssh ${HOST} rm -f ${PATHS[$i]}/.eosfsid ${PATHS[$i]}/.eosfsuuid
            ssh ${HOST} "echo ${UUID} > ${PATHS[$i]}/.eosfsuuid" &> /dev/null
        fi

        eos -b fs add ${UUID} ${FSTS[$i]} ${PATHS[$i]} ${SPACE[$i]} rw
        eos -b fs boot ${UUID} &> /dev/null
    fi

    eos space set ${SPACE[$i]} on &> /dev/null
    IDS[$i]=$(eos -b fs ls -m | grep ${FSTS[$i]%%:*} | grep ${PATHS[$i]} | cut -d\  -f3 | cut -d= -f2)
done

# Wait for file systems to come online
${VERBOSE} && echo "Waiting 30 seconds for file systems to come online"

OFFLINE_IDS=()
for count in `seq 1 30`; do
    OFFLINE_IDS=()
    for i in ${IDS[@]}; do
        eos fs ls -m | grep -w id=${i} | grep online | grep booted &> /dev/null
        if [[ $? -ne 0 ]]; then
            OFFLINE_IDS+=(${i})
            break
        fi
    done

    [[ ${#OFFLINE_IDS[@]} -eq 0 ]] && break
    sleep 1
done

# Print offline file systems
if [[ ${#OFFLINE_IDS[@]} -ne 0 ]]; then
    echo "error: following file systems are not online or booted"
    for i in ${OFFLINE_IDS[@]}; do
        echo "#" `eos -b fs ls | grep -w ${i}`
    done

    echo "" && exit 1
fi

# Prepare EOS file systems
for (( i=0; i < ${#IDS[@]}; i++ )); do
    eos -b fs config ${IDS[$i]} logicalpath=true
    eos mkdir -p /eos/dockertest/${SPACE[$i]}
    eos chmod -r 2777 /eos/dockertest/${SPACE[$i]} &> /dev/null
    eos attr set "sys.forced.space=${SPACE[$i]}" /eos/dockertest/${SPACE[$i]}
done

eos mkdir -p /eos/dockertest/${SPACE[1]}/upload/
eos mkdir -p /eos/dockertest/${SPACE[1]}/import/

# Upload test files to external storage
${VERBOSE} && echo "Uploading test files to S3 external storage: ${PATHS[1]}eos/${SPACE[1]}/extfiles/"
TEST_FILE=/tmp/4kb.dat
dd if=/dev/urandom of=${TEST_FILE} bs=1k count=4 &> /dev/null

for i in `seq 0 49`; do
    davix-put --s3accesskey ${EOS_FST_S3_ACCESS_KEY} --s3secretkey ${EOS_FST_S3_SECRET_KEY} \
              --s3alternate --retry 1 ${TEST_FILE} ${PATHS[1]}eos/${SPACE[1]}/extfiles/${i}.dat &
done

QUERY="davix-ls --s3accesskey ${EOS_FST_S3_ACCESS_KEY} --s3secretkey ${EOS_FST_S3_SECRET_KEY} \
                --s3alternate --retry 1 ${PATHS[1]}eos/${SPACE[1]}/extfiles/ 2> /dev/null | wc -l"
wait_result "${QUERY}" 50 60 "S3 upload"
[[ $? -ne 0 ]] && exit 1

#------------------------------------------------------------------------------
# Tests
#------------------------------------------------------------------------------

# TEST #1: upload operation
#       -- upload 50 files to EOS S3 space using xrdcp

${VERBOSE} && print_test 1 "upload operation" "upload 50 files to /eos/dockertest/${SPACE[1]}/upload using xrdcp"

for i in `seq 0 49`; do
    xrdcp -f --nopbar ${TEST_FILE} root://${EOS_MGM_URL}//eos/dockertest/${SPACE[1]}/upload/${i}.dat &
done

QUERY="davix-ls --s3accesskey ${EOS_FST_S3_ACCESS_KEY} --s3secretkey ${EOS_FST_S3_SECRET_KEY} \
                --s3alternate --retry 1 ${PATHS[1]}eos/dockertest/${SPACE[1]}/upload/ 2> /dev/null | grep -v .xattr | wc -l"
wait_result "${QUERY}" 50 60 "EOS upload"

EOS_RESULT=`eos -b ls -l /eos/dockertest/${SPACE[1]}/upload/ | wc -l`
EXT_RESULT=$(eval "${QUERY}")
${VERBOSE} && echo "EOS_RESULT=${EOS_RESULT} EXT_RESULT=${EXT_RESULT}"

if [[ ${EOS_RESULT} != ${EXT_RESULT} ]]; then
    echo "Failed upload operation. Mismatch in number of files between EOS and S3 storage."
    exit 2
fi

# TEST #2: import operation
#       -- import files from S3 to EOS using 'fs import'

${VERBOSE} && print_test 2 "import operation" "import files from S3 to /eos/dockertest/${SPACE[1]}/import using 'fs import'"

eos fs import ${IDS[1]} ${PATHS[1]}eos/${SPACE[1]}/extfiles/ /eos/dockertest/${SPACE[1]}/import/ &> /dev/null

QUERY="eos -b ls -l /eos/dockertest/${SPACE[1]}/import/ | wc -l"
wait_result "${QUERY}" 50 60 "EOS import"

EOS_RESULT=$(eval "${QUERY}")
${VERBOSE} && echo "EOS_RESULT=${EOS_RESULT}"

if [[ ${EOS_RESULT} -ne 50 ]]; then
    echo "Failed import operation. Not all files have been imported."
    exit 2
fi

# TEST #3: move operation
#       -- move imported replicas from S3 to different file system

${VERBOSE} && print_test 3 "move operation" "move imported replicas from S3 to '${SPACE[0]}' file system"

for i in `seq 0 49`; do
    eos -b file move /eos/dockertest/${SPACE[1]}/import/${i}.dat ${IDS[1]} ${IDS[0]} &> /dev/null &
done

QUERY="eos -b fs dumpmd $IDS[0] --path | wc -l"
wait_result "${QUERY}" 50 60 "EOS replica move"
EOS_RESULT=$(eval "${QUERY}")

QUERY="davix-ls --s3accesskey ${EOS_FST_S3_ACCESS_KEY} --s3secretkey ${EOS_FST_S3_SECRET_KEY} \
                --s3alternate --retry 1 ${PATHS[1]}eos/${SPACE[1]}/extfiles/ 2> /dev/null | grep .dat | wc -l"
VERBOSE="nocount" wait_result "${QUERY}" 0 300 "external storage replica drop"
EXT_RESULT=$(eval "${QUERY}")

${VERBOSE} && echo "EOS_RESULT=${EOS_RESULT} EXT_RESULT=${EXT_RESULT}"

if [[ ${EOS_RESULT} -ne 50 ]] || [[ ${EXT_RESULT} -ne 0 ]]; then
    echo "Failed move operation. Not all replicas were successfully moved."
    exit 2
fi

#------------------------------------------------------------------------------
# Clean-up
#------------------------------------------------------------------------------

${VERBOSE} && echo "Cleaning up"

# Remove files from S3 storage
for i in `seq 0 49`; do
    davix-rm --s3accesskey ${EOS_FST_S3_ACCESS_KEY} --s3secretkey ${EOS_FST_S3_SECRET_KEY} \
             --s3alternate --retry 1 ${PATHS[1]}eos/dockertest/${SPACE[1]}/upload/${i}.dat &> /dev/null &
    davix-rm --s3accesskey ${EOS_FST_S3_ACCESS_KEY} --s3secretkey ${EOS_FST_S3_SECRET_KEY} \
             --s3alternate --retry 1 ${PATHS[1]}eos/dockertest/${SPACE[1]}/upload/.${i}.dat.xattr &> /dev/null &
done

# Remove all EOS files and directories
eos rm -rF /eos/dockertest/${SPACE[0]}/*
eos rm -rF /eos/dockertest/${SPACE[1]}/upload/*
eos rm -rF /eos/dockertest/${SPACE[1]}/import/*
eos rmdir /eos/dockertest/${SPACE[0]}/
eos rmdir /eos/dockertest/${SPACE[1]}/upload/
eos rmdir /eos/dockertest/${SPACE[1]}/import/
eos rmdir /eos/dockertest/${SPACE[1]}/

exit 0
